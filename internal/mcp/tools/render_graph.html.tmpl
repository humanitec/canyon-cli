<!DOCTYPE html>
<html>
  <head>
    <title>Canyon</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="./styles.css" />
    <script>
      // Define theme colors
      const lightTheme = {
        text: "#171717",
        text2: "#343434",
        link: "#423b57",
        tableRowBorder: "#ddbab1",
        border: "#ff4444",
        headerBG: "#fff2ee",
        tableRow: "#f0d4cc",
        buttonBG: "#ea9290",
        brand: "#f15a26",
        mainBG: "#F8F1EF",
        secondBG: "#F2E6E2",
        successGreen: "#09983a",
        primary: "#ffffff",
        secondary: "#f0d4cc",
        background: "#fff2ee",
      };

      const darkTheme = {
        text: "#FFFFFF",
        text2: "#EAEAEA",
        link: "#FFFFFF",
        tableRowBorder: "#8577B0",
        border: "#7C66CF",
        headerBG: "#150E20",
        tableRow: "#150E20",
        buttonBG: "#423B57",
        brand: "#F15A26",
        mainBG: "#161616",
        secondBG: "#292538",
        successGreen: "#50D37D",
        primary: "#1f1f1f",
        secondary: "#3d2c27",
        background: "#2a1a14",
      };

      // Get user's theme preference from localStorage or system preference
      function getThemePreference() {
        const savedTheme = localStorage.getItem("theme");
        if (savedTheme) {
          return savedTheme;
        }

        // Check for system preference and return light or dark directly
        if (
          window.matchMedia &&
          window.matchMedia("(prefers-color-scheme: dark)").matches
        ) {
          return "dark";
        }

        return "light"; // Default to light
      }

      // Set initial theme
      const initialTheme = getThemePreference();
      document.documentElement.setAttribute("data-theme", initialTheme);

      // Apply theme colors based on preference
      function applyThemeColors() {
        const currentTheme =
          document.documentElement.getAttribute("data-theme");
        let colors;

        if (currentTheme === "dark") {
          colors = darkTheme;
        } else {
          // Default to light theme for any other value
          colors = lightTheme;
        }

        // Configure Tailwind with the selected theme colors
        tailwind.config = {
          theme: {
            extend: {
              colors: colors,
            },
          },
        };
      }

      // Apply initial theme
      applyThemeColors();
    </script>
  </head>
  <body class="font-sans m-0 p-0 bg-mainBG h-screen flex flex-col">
    <!-- Menubar -->
    <div
      class="flex justify-between items-center bg-headerBG px-8 py-4 border-b border-border"
    >
      <div class="text-text font-bold text-lg">
        <img
          src="https://cdn.glitch.global/1f44bda7-6694-4547-8f1b-1fa1f48b5711/image.png?v=1742980720762"
          alt="Logo"
          class="h-[1em] inline-block"
        />
      </div>
      <div class="flex items-center gap-4">
        <select
          id="theme-selector"
          class="bg-headerBG text-text border border-border rounded py-1 px-2 text-sm"
        >
          <option value="light">üåù</option>
          <option value="dark">üåö</option>
        </select>
        <div
          class="text-link text-md cursor-not-allowed"
          title="We're still working on our docs."
        >
          Documentation
        </div>
      </div>
    </div>

    <div
      class="flex flex-col flex-1 transition-all duration-500 overflow-hidden"
      id="main-container"
    >
      <style>
        /* Hide scrollbars but keep functionality */
        .scrollbar-hide {
          scrollbar-width: none; /* Firefox */
          -ms-overflow-style: none; /* IE and Edge */
        }
        .scrollbar-hide::-webkit-scrollbar {
          display: none; /* Chrome, Safari and Opera */
        }

        /* Make scrollbars transparent */
        .scrollbar-transparent {
          scrollbar-width: thin; /* Firefox */
          scrollbar-color: transparent transparent; /* Firefox */
        }
        .scrollbar-transparent::-webkit-scrollbar {
          width: 8px;
          height: 8px;
          background-color: transparent;
        }
        .scrollbar-transparent::-webkit-scrollbar-thumb {
          background-color: rgba(0, 0, 0, 0.1);
          border-radius: 4px;
        }
        .scrollbar-transparent::-webkit-scrollbar-track {
          background-color: transparent;
        }
      </style>
      <script>
        // Theme switching functionality
        document.addEventListener("DOMContentLoaded", function () {
          const themeSelector = document.getElementById("theme-selector");

          // Set the dropdown to match the current theme
          themeSelector.value = getThemePreference();

          // Listen for theme changes
          themeSelector.addEventListener("change", function () {
            const selectedTheme = this.value;
            document.documentElement.setAttribute("data-theme", selectedTheme);
            localStorage.setItem("theme", selectedTheme);
            applyThemeColors();

            // Update D3 visualization colors
            updateVisualizationColors();

            // Force redraw of the page to apply new theme
            document.body.style.display = "none";
            setTimeout(() => {
              document.body.style.display = "";
            }, 5);
          });

          // Listen for system theme changes and update if no saved preference
          if (window.matchMedia) {
            window
              .matchMedia("(prefers-color-scheme: dark)")
              .addEventListener("change", function (e) {
                // Only apply system preference if there's no saved theme
                if (!localStorage.getItem("theme")) {
                  // Set theme based on new system preference
                  const newTheme = e.matches ? "dark" : "light";
                  document.documentElement.setAttribute("data-theme", newTheme);
                  themeSelector.value = newTheme;
                  applyThemeColors();

                  // Update D3 visualization colors
                  updateVisualizationColors();

                  // Force redraw
                  document.body.style.display = "none";
                  setTimeout(() => {
                    document.body.style.display = "";
                  }, 5);
                }
              });
          }
        });
      </script>
      <div id="button-bar" class="flex gap-2.5 px-8 pt-8 pb-2 items-center">
        <button
          id="reset-highlight"
          class="bg-buttonBG text-text border-none py-2 px-4 rounded cursor-pointer text-sm transition-colors hover:bg-tableRowBorder"
        >
          Reset View
        </button>
        <div class="relative ml-2">
          <input
            type="text"
            id="search-nodes"
            placeholder="Search nodes..."
            class="border border-border rounded py-2 px-3 text-sm focus:outline-none focus:ring-1 focus:ring-brand"
          />
          <button
            id="clear-search"
            class="absolute right-2 top-1/2 transform -translate-y-1/2 text-xs text-text opacity-70 hover:opacity-100"
            style="display: none"
          >
            ‚úï
          </button>
        </div>
      </div>
      <div
        class="flex flex-1 p-8 pt-2.5 h-full transition-all duration-500"
        id="combined-container"
      >
        <div
          class="flex-1 transition-all h-full overflow-hidden duration-500 border rounded-md border-border"
          id="graph-container"
        >
          <div id="graph" class="w-full h-full bg-mainBG"></div>
        </div>
        <div
          class="hidden bg-secondBG overflow-scroll scrollbar-transparent transition-all border border-border rounded-md p-4 duration-500 ml-5"
          id="details-container"
        >
          <div id="node-details"></div>
          <div id="node-actions" class="mt-2.5">
            <button
              id="toggle-nodes"
              class="bg-buttonBG text-text border-none py-2 px-4 rounded cursor-pointer text-sm transition-colors hover:bg-tableRowBorder"
            >
              Hide Unconnected Nodes
            </button>
          </div>
        </div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script>
      // Data
      const data = JSON.parse({{ toRawJsonJs .data }});

      // Function to get current theme colors
      function getThemeColors() {
        const currentTheme =
          document.documentElement.getAttribute("data-theme");
        let colors;

        if (currentTheme === "dark") {
          colors = darkTheme;
        } else {
          colors = lightTheme; // Default to light theme for any other value
        }

        return colors;
      }

      // Get theme-aware color palette
      function getNodeColorPalette() {
        const themeColors = getThemeColors();

        // Use different color palettes based on theme
        if (themeColors === darkTheme) {
          return [
            "#8B5CF6", // violet-500
            "#EC4899", // pink-500
            "#3B82F6", // blue-500
            "#10B981", // emerald-500
          ];
        } else {
          return [
            "#fecaca", // red-200
            "#fed7aa", // orange-200
            "#bfdbfe", // blue-200
            "#a7f3d0", // emerald-200
          ];
        }
      }

      // Create a color scale based on the class
      let color = d3
        .scaleOrdinal()
        .domain(["org", "app", "workload", "resource"])
        .range(getNodeColorPalette()); // Use theme-aware colors

      // Function to update visualization colors when theme changes
      function updateVisualizationColors() {
        // Update color scale with new theme colors
        color.range(getNodeColorPalette());
        const themeColors = getThemeColors();

        // Update node colors
        node.selectAll("circle").style("fill", (d) => color(d.class));
        node
          .selectAll("rect.node-label-bg")
          .style("fill", (d) => color(d.class));

        // Update text colors
        node.selectAll("text").style("fill", themeColors.text);
        linkText.style("fill", themeColors.text);

        // Update link colors if not highlighted
        if (!currentSelectedNode) {
          link.style("stroke", themeColors.buttonBG);
        }

        // If there's a selected node, reapply highlighting with new theme colors
        if (currentSelectedNode) {
          highlightConnections(currentSelectedNode);
        }
      }

      // Get the graph container dimensions
      const graphContainer = document.getElementById("graph-container");
      const width = graphContainer.clientWidth;
      const height = graphContainer.clientHeight; // Use the full height of the container

      // Create SVG element
      const svg = d3
        .select("#graph")
        .append("svg")
        .attr("width", width)
        .attr("height", height)
        .call(
          d3
            .zoom()
            .filter((event) => {
              // Prevent double-click zoom but allow other zoom events
              return !event.type.includes("dblclick");
            })
            .on("zoom", function (event) {
              container.attr("transform", event.transform);
            })
        );

      // Container for the graph
      const container = svg.append("g");

      // Generate random connection words
      const connectionWords = [
        "Depends",
        "Connects",
        "Requires",
        "Integrates",
        "Exchanges",
        "Provides",
        "Consumes",
        "Accesses",
        "Supplies",
        "Queries",
        "Updates",
        "Monitors",
        "Controls",
        "Validates",
        "Secures",
        "Logs",
        "Extends",
        "Processes",
        "Authorizes",
        "Invokes",
      ];

      // Assign a random explanation to each link
      data.links.forEach((link) => {
        link.explanation =
          connectionWords[Math.floor(Math.random() * connectionWords.length)];
      });

      // Initialize the links as groups
      const linkGroups = container
        .append("g")
        .selectAll(".link-group")
        .data(data.links)
        .enter()
        .append("g")
        .attr("class", "link-group");

      // Add the line for each link
      const link = linkGroups
        .append("line")
        .attr(
          "class",
          "stroke-buttonBG stroke-opacity-60 transition-all duration-300"
        )
        .style("stroke-width", 2);

      // Add background rectangles for the link text (initially hidden)
      const linkTextBg = linkGroups
        .append("rect")
        .attr("class", "fill-tableRowBorder rounded-md opacity-0")
        .attr("rx", 3)
        .attr("ry", 3)
        .attr("width", 0)
        .attr("height", 0)
        .attr("x", 0)
        .attr("y", 0);

      // Add the explanation text for each link (hidden by default)
      const linkText = linkGroups
        .append("text")
        .attr("class", "text-xs font-bold pointer-events-none opacity-0")
        .style("fill", () => getThemeColors().text) // Use theme text color
        .text((d) => d.explanation)
        .attr("text-anchor", "middle")
        .attr("dy", -5);

      // Initialize the nodes with drag functionality
      const node = container
        .append("g")
        .selectAll(".node")
        .data(data.nodes)
        .enter()
        .append("g")
        .attr("class", "cursor-pointer")
        .call(
          d3
            .drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended)
        );

      // Add circles to the nodes
      node
        .append("circle")
        .attr("r", (d) => {
          // Set radius based on class
          switch (d.class) {
            case "org":
              return 16; // Largest
            case "app":
              return 14;
            case "workload":
              return 12;
            case "resource":
              return 10; // Smallest
            default:
              return 12;
          }
        })
        .attr(
          "class",
          "stroke-white stroke-0.5 transition-opacity duration-300"
        )
        .style("fill", (d) => color(d.class));

      // Add background rectangles for node labels
      const labelBgs = node
        .append("rect")
        .attr(
          "class",
          "rounded transition-opacity duration-300 opacity-80 node-label-bg"
        )
        .attr("rx", 3)
        .attr("ry", 3)
        .style("fill", (d) => color(d.class));

      // Add labels to the nodes
      const labels = node
        .append("text")
        .text((d) => d.id)
        .attr(
          "class",
          "text-xs pointer-events-none transition-opacity duration-300"
        )
        .style("fill", () => getThemeColors().text) // Use theme text color
        .attr("dx", 15)
        .attr("dy", 4);

      // Store initial positions for nodes
      let initialPositions = [];

      // Variables to control force parameters
      // Reduce movement by lowering alphaTarget and increasing strength values
      let linkDistance = 50;
      let chargeStrength = -1000;
      let nodeCollideRadius = (d) => 20;

      // Create the simulation with reduced movement
      const simulation = d3
        .forceSimulation(data.nodes)
        .force(
          "link",
          d3
            .forceLink(data.links)
            .id((d) => d.id)
            .distance(() => linkDistance)
        )
        .force(
          "charge",
          d3.forceManyBody().strength(() => chargeStrength)
        )
        .force("center", d3.forceCenter(width / 2, height / 2))
        .force(
          "collide",
          d3.forceCollide().radius(nodeCollideRadius).iterations(2)
        );

      // Function to handle window resize
      function handleResize() {
        const graphContainer = document.getElementById("graph-container");

        svg
          .attr("width", graphContainer.clientWidth)
          .attr("height", graphContainer.clientHeight);

        // Update force center
        simulation.force(
          "center",
          d3.forceCenter(
            graphContainer.clientWidth / 2,
            graphContainer.clientHeight / 2
          )
        );
      }

      // Listen for window resize
      window.addEventListener("resize", handleResize);

      // Initial layout (full screen)
      toggleLayout(false);

      // Save initial positions after the simulation has settled
      simulation.on("end", () => {
        // Store initial positions for all nodes
        data.nodes.forEach((node) => {
          initialPositions.push({
            id: node.id,
            x: node.x,
            y: node.y,
          });
        });
      });

      // Update positions during simulation
      simulation.on("tick", () => {
        // Update link lines
        link
          .attr("x1", (d) => d.source.x)
          .attr("y1", (d) => d.source.y)
          .attr("x2", (d) => d.target.x)
          .attr("y2", (d) => d.target.y);

        // Update link explanation position (text and background)
        linkGroups.each(function (d) {
          const linkGroup = d3.select(this);
          const textElement = linkGroup.select("text");
          const bgElement = linkGroup.select("rect");

          // Calculate the center point of the link
          const x = (d.source.x + d.target.x) / 2;
          const y = (d.source.y + d.target.y) / 2;

          // Position the text at the center
          textElement.attr("x", x).attr("y", y - 5);

          // Get the bounding box of the text to size the background correctly
          if (textElement.node()) {
            const bbox = textElement.node().getBBox();

            // Position the background rectangle to encompass the text
            bgElement
              .attr("x", bbox.x - 4)
              .attr("y", bbox.y - 2)
              .attr("width", bbox.width + 8)
              .attr("height", bbox.height + 4);
          }
        });

        // Update nodes
        node.attr("transform", (d) => `translate(${d.x}, ${d.y})`);

        // Update node label backgrounds based on text size
        node.each(function () {
          const nodeGroup = d3.select(this);
          const textElement = nodeGroup.select("text");
          const bgElement = nodeGroup.select("rect.node-label-bg");

          if (textElement.node()) {
            const bbox = textElement.node().getBBox();

            // Position the background rectangle to encompass the text
            bgElement
              .attr("x", bbox.x - 2)
              .attr("y", bbox.y - 1)
              .attr("width", bbox.width + 4)
              .attr("height", bbox.height + 2);
          }
        });
      });

      // Store current selected node globally
      let currentSelectedNode = null;
      let currentConnectedNodeIds = new Set();

      // Function to move a node to the left third of the screen quickly
      function moveNodeToLeftThird(d) {
        const graphContainer = document.getElementById("graph-container");
        const leftThirdX = graphContainer.clientWidth / 3;
        const centerY = graphContainer.clientHeight / 2;

        // Apply direct positioning to the selected node
        d.fx = leftThirdX; // Fix the x position
        d.fy = centerY; // Fix the y position

        // Apply immediate transition
        d.x = leftThirdX;
        d.y = centerY;

        // Temporarily boost simulation to better position connected nodes
        simulation.alpha(0.3).restart();

        // Release fixed position after a delay to allow for later interactions
        setTimeout(() => {
          if (currentSelectedNode === d) {
            // Keep it fixed while selected
            d.fx = leftThirdX;
            d.fy = centerY;
          }
        }, 100);
      }

      // Toggle layout function
      function toggleLayout(showDetails) {
        const combinedContainer = document.getElementById("combined-container");
        const graphContainer = document.getElementById("graph-container");
        const detailsContainer = document.getElementById("details-container");

        if (showDetails) {
          // Switch to split view
          combinedContainer.style.flexDirection = "row";
          graphContainer.style.width = "66.6%";
          detailsContainer.style.display = "block";
          detailsContainer.style.width = "33.3%";

          // Trigger resize to update the graph
          setTimeout(handleResize, 10);
        } else {
          // Switch to full screen graph
          combinedContainer.style.flexDirection = "row";
          graphContainer.style.width = "100%";
          detailsContainer.style.display = "none";

          // Trigger resize to update the graph
          setTimeout(handleResize, 10);
        }
      }

      // Function to highlight connections
      function highlightConnections(selectedNode) {
        // Store current selection
        currentSelectedNode = selectedNode;
        currentConnectedNodeIds = new Set();

        // Find connected nodes and links
        const connectedLinks = [];

        data.links.forEach((link) => {
          if (
            link.source.id === selectedNode.id ||
            link.target.id === selectedNode.id
          ) {
            currentConnectedNodeIds.add(
              typeof link.source === "object" ? link.source.id : link.source
            );
            currentConnectedNodeIds.add(
              typeof link.target === "object" ? link.target.id : link.target
            );
            connectedLinks.push(link);
          }
        });

        // Fix positions of all nodes to prevent movement when highlighting
        data.nodes.forEach((node) => {
          node.fx = node.x;
          node.fy = node.y;
        });

        // Reduce opacity for all nodes
        node.select("circle").style("opacity", 0.2);
        node.select("text").style("opacity", 0.2);
        node.select("rect.node-label-bg").style("opacity", 0.2);

        // Highlight the selected node and its connections
        node
          .filter((d) => currentConnectedNodeIds.has(d.id))
          .select("circle")
          .style("opacity", 1);

        node
          .filter((d) => currentConnectedNodeIds.has(d.id))
          .select("text")
          .style("opacity", 1);

        node
          .filter((d) => currentConnectedNodeIds.has(d.id))
          .select("rect.node-label-bg")
          .style("opacity", 0.8);

        // Highlight connected links
        linkGroups.each(function (d) {
          const sourceId =
            typeof d.source === "object" ? d.source.id : d.source;
          const targetId =
            typeof d.target === "object" ? d.target.id : d.target;
          const isConnected =
            sourceId === selectedNode.id || targetId === selectedNode.id;

          const linkElement = d3.select(this).select("line");
          const textElement = d3.select(this).select("text");
          const bgElement = d3.select(this).select("rect");

          if (isConnected) {
            const themeColors = getThemeColors();
            linkElement
              .style("stroke-opacity", 1)
              .style("stroke", themeColors.brand) // Use theme brand color
              .style("stroke-width", 3);

            // Show both the text and its background
            textElement.style("opacity", 1);
            bgElement.style("opacity", 1);
          } else {
            linkElement.style("stroke-opacity", 0.1);
            textElement.style("opacity", 0);
            bgElement.style("opacity", 0);
          }
        });

        // Display node details
        const nodeDetailsDiv = document.getElementById("node-details");

        // Get connected nodes
        const neighbors = [...currentConnectedNodeIds].filter(
          (id) => id !== selectedNode.id
        );

        nodeDetailsDiv.innerHTML = `
          <h2 class="text-xl font-bold mb-2 text-text">${selectedNode.id}</h2>
          <p class="mb-2 text-text"><span class="font-semibold">Class:</span> ${
            selectedNode.class
          }</p>
          <p class="font-semibold mb-1 text-text">Connected to ${
            neighbors.length
          } nodes:</p>
          <ul class="bg-primary bg-opacity-50 rounded p-2 max-h-80 overflow-y-auto scrollbar-transparent">
            ${neighbors
              .map(
                (id) =>
                  `<li class="mb-1 hover:bg-primary hover:bg-opacity-20 p-1 rounded text-text">${id}</li>`
              )
              .join("")}
          </ul>
        `;

        // Show details container with split layout
        toggleLayout(true);
      }

      // Store search state
      let currentSearchTerm = "";

      // Reset highlight function
      function resetHighlight() {
        // Release fixed positions for all nodes
        data.nodes.forEach((node) => {
          node.fx = null;
          node.fy = null;
        });

        // Show all nodes again
        node.style("display", "");

        // Reset opacities and styles, but respect search filter if active
        if (currentSearchTerm) {
          applySearchFilter(currentSearchTerm);
        } else {
          node.select("circle").style("opacity", 1);
          node.select("text").style("opacity", 1);
          node.select("rect.node-label-bg").style("opacity", 0.8);
        }

        // Reset link styles
        linkGroups.style("display", "");
        const themeColors = getThemeColors();
        link
          .style("stroke-opacity", 0.6)
          .style("stroke", themeColors.buttonBG) // Use theme buttonBG color
          .style("stroke-width", 2);

        // Hide all link texts and backgrounds
        linkText.style("opacity", 0);
        linkTextBg.style("opacity", 0);

        // Reset layout to full screen
        toggleLayout(false);

        // Clear current selection
        currentSelectedNode = null;
        currentConnectedNodeIds = new Set();

        // Restart with minimal movement
        simulation.alpha(0.1).restart();
      }

      // Function to hide unconnected nodes
      function hideUnconnectedNodes() {
        if (!currentSelectedNode) return;

        // Hide unconnected nodes
        node
          .filter((d) => !currentConnectedNodeIds.has(d.id))
          .style("display", "none");

        // Hide links that don't connect to our selected node
        linkGroups.each(function (d) {
          const sourceId =
            typeof d.source === "object" ? d.source.id : d.source;
          const targetId =
            typeof d.target === "object" ? d.target.id : d.target;
          const isConnected =
            sourceId === currentSelectedNode.id ||
            targetId === currentSelectedNode.id;

          if (!isConnected) {
            d3.select(this).style("display", "none");
          }
        });
      }

      // Function to show all nodes
      function showAllNodes() {
        if (!currentSelectedNode) return;

        // Show all nodes but keep highlighting
        node.style("display", "");
        link.style("display", "");

        // Reapply highlight effect
        highlightConnections(currentSelectedNode);
      }

      // Add click handling for nodes
      node.on("click", (event, d) => {
        event.stopPropagation(); // Prevent event bubbling
        highlightConnections(d);
      });

      // Click on background to reset
      svg.on("click", (event) => {
        if (event.target.tagName === "svg" || event.target.tagName === "rect") {
          resetHighlight();
        }
      });

      // Function to apply search filter
      function applySearchFilter(searchTerm) {
        if (!searchTerm) {
          // If search is cleared, reset all nodes to full opacity
          node.select("circle").style("opacity", 1);
          node.select("text").style("opacity", 1);
          node.select("rect.node-label-bg").style("opacity", 0.8);

          // Reset all links to default opacity
          link.style("stroke-opacity", 0.6);
          return;
        }

        // Convert to lowercase for case-insensitive comparison
        const term = searchTerm.toLowerCase();

        // Track which nodes match the search
        const matchingNodeIds = new Set();

        // Apply opacity based on match
        node.each(function (d) {
          const nodeElement = d3.select(this);
          const matches = d.id.toLowerCase().includes(term);

          if (matches) {
            matchingNodeIds.add(d.id);
          }

          // Use Tailwind's opacity classes by setting style directly
          nodeElement.select("circle").style("opacity", matches ? 1 : 0.1);
          nodeElement.select("text").style("opacity", matches ? 1 : 0.1);
          nodeElement
            .select("rect.node-label-bg")
            .style("opacity", matches ? 0.8 : 0.1);
        });

        // Update link opacity based on whether they connect matching nodes
        linkGroups.each(function (d) {
          const linkElement = d3.select(this).select("line");
          const sourceId =
            typeof d.source === "object" ? d.source.id : d.source;
          const targetId =
            typeof d.target === "object" ? d.target.id : d.target;

          // If either source or target matches, keep link visible
          const isRelevant =
            matchingNodeIds.has(sourceId) || matchingNodeIds.has(targetId);

          // Set opacity accordingly
          linkElement.style("stroke-opacity", isRelevant ? 0.6 : 0.1);
        });
      }

      // Button event handlers
      d3.select("#reset-highlight").on("click", function () {
        // Clear search when resetting view
        const searchInput = document.getElementById("search-nodes");
        searchInput.value = "";
        currentSearchTerm = "";
        document.getElementById("clear-search").style.display = "none";

        resetHighlight();
      });

      // Search functionality
      const searchInput = document.getElementById("search-nodes");
      const clearButton = document.getElementById("clear-search");

      searchInput.addEventListener("input", function () {
        const searchTerm = this.value.trim();
        currentSearchTerm = searchTerm;

        // Show/hide clear button
        clearButton.style.display = searchTerm ? "block" : "none";

        // Apply search filter
        applySearchFilter(searchTerm);
      });

      // Clear search button
      clearButton.addEventListener("click", function () {
        searchInput.value = "";
        currentSearchTerm = "";
        this.style.display = "none";
        applySearchFilter("");
      });

      // Toggle nodes visibility state
      let nodesHidden = false;
      d3.select("#toggle-nodes").on("click", function () {
        if (nodesHidden) {
          // Show all nodes
          showAllNodes();
          d3.select(this).text("Hide Unconnected Nodes");
        } else {
          // Hide unconnected nodes
          hideUnconnectedNodes();
          d3.select(this).text("Show All Nodes");
        }
        nodesHidden = !nodesHidden;
      });

      // Drag functions
      function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      }

      function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
      }

      function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0.01);
        // Keep the node fixed where it was dragged
        // (don't reset d.fx and d.fy to null)
      }
    </script>
  </body>
</html>
